# 上下文管理文档

> **Version**: v1.4.0
> **Last Updated**: 2026-02-07
> **Component**: ContextManager

本文档描述 BA-Agent 的上下文管理机制，包括上下文如何被传递、处理以及各组件的触发时机。

---

## 目录

1. [架构概览](#架构概览)
2. [上下文构建流程](#上下文构建流程)
3. [代码文件管理](#代码文件管理)
4. [代码引用机制](#代码引用机制)
5. [上下文清理策略](#上下文清理策略)
6. [触发时机详解](#触发时机详解)
7. [组件职责划分](#组件职责划分)

---

## 架构概览

### 整体架构图

```
用户请求
    │
    ▼
┌─────────────────┐
│ BAAgentService  │
│     .query()    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ContextManager  │
│  .build_context()│
│  ┌─────────────┐│
│  │1.历史清理   ││
│  │2.系统提示   ││
│  │3.代码列表   ││
│  │4.文件上下文 ││
│  │5.用户消息   ││
│  └─────────────┘│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   模型调用       │
│   (LangGraph)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ StructuredResponse│
│   + code_blocks │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   CodeStore     │
│   (保存代码)     │
└─────────────────┘
```

### 设计原则

| 原则 | 说明 |
|------|------|
| **统一管理** | 所有上下文处理逻辑集中在 ContextManager |
| **职责分离** | 存储、构建、调用职责清晰划分 |
| **自动优化** | 自动清理冗余内容，节省 token |
| **可追踪** | 清晰的触发时机和处理流程 |

---

## 上下文构建流程

### 标准处理顺序

每次用户查询时，上下文按以下顺序构建：

#### 第 1 步：历史消息清理

如果提供了历史对话消息，首先清理其中 read_file 工具返回的文件内容，替换为梗概。这可以大幅减少 token 使用量，因为文件内容通常很长。

**处理方式**：
- 检测消息是否来自 read_file 工具（tool_call_id 以 "call_read_file_" 开头）
- 将文件内容替换为梗概，格式如：`[文件已读取] sales_analysis.py (python, 150行, 函数: load_data, clean_data)`
- 保留文件的关键元数据信息（文件名、类型、行数、函数/类列表等）

**梗概示例**：
```
[文件已读取] sales_analysis.py (python, 150行, 函数: load_data, clean_data, visualize)
[文件已读取] data.csv (CSV, 5000行, 列: date, product, amount, region)
[文件已读取] chart_result.json (JSON, 2.5KB, 键: config, data, options)
```

#### 第 2 步：添加系统提示

插入结构化响应系统提示词，告诉模型必须返回符合特定 JSON 格式的响应。

**内容**：包含响应格式定义、工具调用规范、代码块处理规则、支持的语言类型等。

#### 第 3 步：添加可用代码文件列表

如果会话中已有代码文件，系统会生成一个代码文件列表并添加到上下文中。

**格式示例**：
```
可用代码文件列表：
- code_sales_analysis (python) - 销售数据分析
- code_visualization_chart (python) - 趋势图表
- code_report_template (html) - 报告模板

你可以通过 <code_ref>{code_id}</code_ref> 标签在最终报告中引用这些代码。
```

**作用**：让模型知道本次对话中有哪些已创建的代码文件可以引用。

#### 第 4 步：处理用户上传的文件上下文

如果用户上传了文件，添加文件引用信息到上下文中。

**格式**：生成特定格式的引用，让模型知道有哪些文件可用。

#### 第 5 步：添加用户消息

最后，将用户的当前消息添加到上下文列表中。

### 完整消息列表结构

```
[
  {role: "system", content: "历史消息（已清理文件内容为梗概）"},
  {role: "system", content: "结构化响应系统提示"},
  {role: "system", content: "可用代码文件列表（如有）"},
  {role: "system", content: "文件上下文引用（如有）"},
  {role: "user", content: "用户当前消息"}
]
```

---

## 代码文件管理

### 支持的语言类型

系统支持保存多种语言格式的代码文件：

| 语言类型 | 文件扩展名 | 主要用途 |
|---------|-----------|----------|
| Python | .py | 数据分析、计算、可视化 |
| JavaScript | .js | 前端交互 |
| HTML | .html | 网页结构 |
| CSS | .css | 样式设计 |
| SQL | .sql | 数据库查询 |
| Shell/Bash | .sh | 系统脚本 |
| Markdown | .md | 文档 |

其他支持语言：TypeScript, JSON, YAML, XML, R, Java, C/C++, Go, Rust, PHP, Ruby

### 语言验证机制

当模型创建代码时，系统会验证语言类型：

1. 检查模型指定的 language 是否在支持列表中
2. 如果不支持，自动降级为 python 并记录警告
3. 根据语言类型选择正确的文件扩展名
4. 将代码保存到对应的文件格式

### 文件存储位置

所有代码文件保存在存储目录的 data 子目录中，文件名格式为 `{code_id}.{扩展名}`。

### 代码元数据

每个保存的代码文件包含以下元数据：

| 字段 | 说明 | 来源 |
|------|------|------|
| code_id | 代码唯一标识 | 模型生成 |
| language | 代码语言类型 | 模型指定 |
| description | 代码描述 | 模型提供或自动生成 |
| line_count | 代码行数 | 自动计算 |
| char_count | 字符数量 | 自动计算 |
| created_at | 创建时间 | 自动记录 |

---

## 文件读取机制

### 模型主动读取

v1.4.0 起，移除了自动代码注入机制，改为模型通过 `file_reader` 工具主动读取文件。

**读取流程**：

1. **模型决策**：模型根据任务需要判断是否需要读取文件
2. **工具调用**：模型调用 `file_reader` 工具，指定文件路径或 ID
3. **返回内容**：系统返回完整的文件内容给模型
4. **内容清理**：下一轮对话中，文件内容被自动清理为梗概

**梗概示例**：
- 代码文件：`[文件已读取] sales_analysis.py (python, 150行, 函数: load_data, clean_data, visualize)`
- 数据文件：`[文件已读取] data.csv (CSV, 5000行, 列: date, product, amount, region)`
- JSON 文件：`[文件已读取] config.json (JSON, 2.5KB, 键: settings, data, options)`

### 文件内容清理策略

**清理时机**：每次构建新上下文时，自动清理历史消息中 read_file 返回的文件内容。

**清理方式**：

1. 检测消息是否来自 read_file 工具（tool_call_id 以 "call_read_file_" 开头）
2. 解析文件路径、内容和元数据
3. 根据文件类型生成梗概
4. 将完整内容替换为梗概

**不同文件类型的梗概格式**：

| 文件类型 | 梗概内容 |
|----------|----------|
| Python/JS/Java 等代码 | 文件名、语言、行数、函数列表、类列表 |
| CSV/Excel 数据文件 | 文件名、类型、行数、列名 |
| JSON 配置文件 | 文件名、大小、顶层键 |
| 其他文本文件 | 文件名、类型、大小 |

### Token 优化效果

通过内容清理机制，可实现：

| 场景 | 无清理 | 有清理 | 节省 |
|------|--------|--------|------|
| 5 轮对话，读取 3 个文件 | ~6000 tokens | ~1500 tokens | 75% |
| 10 轮对话，读取 5 个文件 | ~12000 tokens | ~2000 tokens | 83% |

### 代码引用机制（保留）

<note>此部分仅描述 complete 阶段的 `<code_ref>` 机制，代码不进入上下文，直接传前端渲染。</note>

### 代码生命周期

```
┌──────────────────────────────────────────────────────────────────┐
│                      文件读取生命周期                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  第 N 轮：模型创建代码                                            │
│  ├─ 模型在 code_blocks 中提供代码                                │
│  ├─ 验证语言类型并选择文件扩展名                                 │
│  ├─ 后端保存到 data/code_xxx.{扩展名}                           │
│  └─ 添加到可用文件列表                                           │
│                                                                  │
│  第 N+1 轮：模型读取文件                                          │
│  ├─ 模型调用 file_reader 工具                                    │
│  ├─ 从 CodeStore 读取完整代码                                    │
│  └─ 文件内容返回给模型 (~1000 tokens)                           │
│                                                                  │
│  第 N+2 轮：继续对话                                             │
│  ├─ 文件内容被清理为梗概                                         │
│  └─ 节省 ~900 tokens                                            │
│                                                                  │
│  第 N+M 轮：再次读取                                             │
│  └─ 模型重新调用 file_reader，可反复使用                         │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### 上下文总结

**触发条件**（满足任一即触发）：

- 消息总数超过 20 条

**总结策略**（简化版）：

1. 保留所有系统提示消息
2. 保留最近的 5 条对话消息
3. 移除更早的消息内容

**说明**：当前实现使用简化策略，未来可升级为使用 LLM 生成摘要。

---

## 触发时机详解

### 完整时序图

```
用户查询
    │
    ├─ API 接收请求
    │
    ▼
BAAgentService.query()
    │
    ├─ [触发] ContextManager.build_context()
    │   │
    │   ├─ [检查] 是否有历史消息？
    │   │   └─ 是 → clean_file_contents() 清理文件内容为梗概
    │   │
    │   ├─ [添加] 系统提示消息
    │   │
    │   ├─ [检查] 会话是否有代码文件？
    │   │   └─ 是 → 构建可用代码文件列表
    │   │
    │   ├─ [检查] 是否有文件上下文？
    │   │   └─ 是 → 添加文件引用信息
    │   │
    │   └─ [添加] 用户消息
    │
    ├─ [检查] should_clean_context()？
    │   └─ 是 → summarize_context() 压缩上下文
    │
    ▼
模型调用 (LangGraph)
    │
    ├─ 返回 StructuredResponse
    │
    ▼
BAAgentService._extract_response_content()
    │
    ├─ [检查] 响应是否包含 code_blocks？
    │   ├─ 验证语言类型
    │   ├─ 选择文件扩展名
    │   └─ CodeStore.store() 保存代码
    │
    ▼
返回给用户
```

### 触发点清单

| 触发点 | 触发条件 | 执行操作 | 执行位置 |
|--------|----------|----------|----------|
| **上下文构建** | 每次用户查询 | 构建完整消息列表 | BAAgentService.query() |
| **历史清理** | 提供了 history_messages | 清理文件内容为梗概 | build_context() 内部 |
| **代码列表构建** | 会话有代码文件 | 生成可用代码列表 | build_context() 内部 |
| **上下文总结** | 消息 > 20 | 压缩消息列表 | query() 检查后 |
| **代码保存** | 响应包含 code_blocks | 验证并保存到文件 | 响应处理阶段 |

### 决策流程图

```
开始构建上下文
    │
    ├─ 有历史消息？
    │   ├─ 是 → 清理文件内容为梗概 → 添加到消息列表
    │   └─ 否 → 继续
    │
    ├─ 添加系统提示
    │
    ├─ 会话有代码文件？
    │   ├─ 是 → 构建代码列表 → 添加到消息
    │   └─ 否 → 继续
    │
    ├─ 有文件上下文？
    │   ├─ 是 → 添加文件引用 → 继续
    │   └─ 否 → 继续
    │
    ├─ 添加用户消息
    │
    ▼
上下文构建完成
    │
    ├─ 消息数量 > 20？
    │   ├─ 是 → 上下文总结
    │   └─ 否 → 继续
    │
    ▼
传递给模型
```

---

## 组件职责划分

### ContextManager（上下文管理器）

**核心职责**：

- 消息列表构建和组装
- 文件内容的清理和梗概生成
- 上下文压缩和总结
- 文件上下文处理
- 可用代码文件列表构建

**不负责**：

- 文件读写（由 CodeStore 负责）
- 模型调用（由 BAAgentService 负责）
- 响应解析（由 BAAgentService 负责）

### CodeStore（代码存储）

**核心职责**：

- 代码文件的持久化存储（支持多种语言格式）
- 代码文件的读取和检索
- 代码索引管理（SQLite）
- 语言类型验证和文件扩展名选择
- CODE_SAVED 标记生成（用户通知）
- 会话代码列表查询

**不负责**：

- 消息构建（由 ContextManager 负责）
- 上下文管理（由 ContextManager 负责）
- 模型交互（由 BAAgentService 负责）

### BAAgentService（业务服务）

**核心职责**：

- API 端点处理和请求路由
- 查询流程的编排
- 模型调用和结果处理
- 响应内容的解析和提取
- 对话状态管理

**不负责**：

- 上下文构建细节（委托给 ContextManager）
- 文件存储细节（委托给 CodeStore）
- 底层工具调用（由 LangGraph 处理）

### 职责边界图

```
┌─────────────────────────────────────────────────────────────┐
│                    BAAgentService                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  请求处理 → 模型调用 → 响应处理 → 返回结果           │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│           ┌──────────────┴──────────────┐                  │
│           ▼                             ▼                  │
│  ┌────────────────────┐    ┌─────────────────────┐        │
│  │  ContextManager    │    │    CodeStore        │        │
│  │  ────────────────  │    │  ────────────────   │        │
│  │  • 上下文构建      │    │  • 多格式文件存储    │        │
│  │  • 代码注入        │    │  • 语言验证          │        │
│  │  • 上下文清理      │    │  • 代码读写          │        │
│  │  • 代码列表构建    │    │  • 索引管理          │        │
│  └────────────────────┘    └─────────────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

---

## 实际应用场景

### 场景 1：多语言代码创建与复用

**创建代码**

用户请求创建代码，模型指定 language 类型，系统验证并保存到对应格式的文件。

**引用代码**

用户在消息中使用 code_id 引用，系统检测并注入完整的代码内容供模型使用。

**继续对话**

下一轮自动清理注入的代码，节省 token。

### 场景 2：代码文件列表引导

**场景描述**

用户开始新一轮对话，系统自动提供可用代码文件列表。

**处理流程**

1. 系统从 CodeStore 查询会话中的所有代码文件
2. 生成包含 code_id、language、description 的列表
3. 模型看到列表后可以在报告中使用 `<code_ref>code_id</code_ref>` 引用代码

### 场景 3：长对话优化

**场景描述**

经过多轮对话后，上下文过长。

**处理流程**

1. 系统检测到消息数量或代码块数量超过阈值
2. 触发上下文总结
3. 保留系统提示和最近的消息
4. 压缩上下文，保持响应速度

---

## 最佳实践

### 代码标识命名

| 推荐 | 原因 |
|------|------|
| `code_sales_analysis` | 清晰描述功能 |
| `code_data_cleaning` | 明确操作类型 |
| `code_chart_visualization` | 包含输出类型 |
| `code_db_query_customers` | 说明数据源 |

| 不推荐 | 原因 |
|------|------|
| `code_abc` | 无描述性 |
| `code_123` | 数字无法传达含义 |
| `code_sales_data_analysis_for_q1_2024_report` | 过于冗长 |

### 文件读取方式

模型使用 `file_reader` 工具主动读取文件：

```
请读取 code_sales_analysis 文件并进行分析
基于 file_data_cleaning 中的数据继续处理
```

模型会根据任务需要判断何时读取文件，系统会自动管理文件内容的清理和梗概生成。

### Token 使用优化建议

- 自动清理：系统自动将已读取的文件内容清理为梗概
- 按需读取：模型根据任务需要主动读取文件，无需手动管理
- 定期总结：长对话会自动压缩，保持响应速度

---

## 相关文档

- [响应流程文档](./response-flow.md) - 完整的请求-响应流程
- [系统提示词](./prompts.md) - 结构化响应格式定义
- [文件存储系统](../backend/filestore/README.md) - CodeStore 实现细节

---

## 变更日志

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| v1.4.0 | 2026-02-07 | 移除自动代码注入机制，改用模型主动调用 file_reader；添加文件读取后内容清理为梗概的机制 |
| v1.3.0 | 2026-02-07 | 添加统一文件列表机制（代码+上传）、file_ref 标签、markdown 格式 |
| v1.2.0 | 2026-02-07 | 添加代码文件管理、多语言支持、可用代码列表机制 |
| v1.1.0 | 2026-02-07 | 重写为纯文字说明，移除代码片段，增强可读性 |
| v1.0.0 | 2026-02-07 | 初始版本，统一的上下文管理架构 |
